
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function (internal, svelte) {
	'use strict';

	/* src\client\src\App.svelte generated by Svelte v3.38.2 */
	const file = "src\\client\\src\\App.svelte";

	function create_fragment(ctx) {
		let main;
		let h1;
		let t0;
		let t1;
		let t2;
		let canvas_1;

		const block = {
			c: function create() {
				main = internal.element("main");
				h1 = internal.element("h1");
				t0 = internal.text("HELLO ");
				t1 = internal.text(/*name*/ ctx[0]);
				t2 = internal.space();
				canvas_1 = internal.element("canvas");
				internal.attr_dev(h1, "class", "svelte-1tky8bj");
				internal.add_location(h1, file, 31, 1, 1082);
				internal.attr_dev(canvas_1, "width", 200);
				internal.attr_dev(canvas_1, "height", 200);
				internal.add_location(canvas_1, file, 32, 1, 1107);
				internal.attr_dev(main, "class", "svelte-1tky8bj");
				internal.add_location(main, file, 30, 0, 1074);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				internal.insert_dev(target, main, anchor);
				internal.append_dev(main, h1);
				internal.append_dev(h1, t0);
				internal.append_dev(h1, t1);
				internal.append_dev(main, t2);
				internal.append_dev(main, canvas_1);
				/*canvas_1_binding*/ ctx[2](canvas_1);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*name*/ 1) internal.set_data_dev(t1, /*name*/ ctx[0]);
			},
			i: internal.noop,
			o: internal.noop,
			d: function destroy(detaching) {
				if (detaching) internal.detach_dev(main);
				/*canvas_1_binding*/ ctx[2](null);
			}
		};

		internal.dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		internal.validate_slots("App", slots, []);
		let { name } = $$props;
		let canvas;

		// Some random canvas animation, feel free to remove:
		svelte.onMount(() => {
			const ctx = canvas.getContext("2d");
			let frame = requestAnimationFrame(loop);

			function loop(t) {
				frame = requestAnimationFrame(loop);
				const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

				for (let p = 0; p < imageData.data.length; p += 4) {
					const i = p / 4;
					const x = i % canvas.width;
					const y = i / canvas.height >>> 0;
					const r = 64 + 128 * x / canvas.width + 64 * Math.sin(t / 1000);
					const g = 64 + 128 * y / canvas.height + 64 * Math.cos(t / 1000);
					const b = 128;
					imageData.data[p + 0] = r;
					imageData.data[p + 1] = g;
					imageData.data[p + 2] = b;
					imageData.data[p + 3] = 255;
				}

				ctx.putImageData(imageData, 0, 0);
			}

			return () => {
				cancelAnimationFrame(frame);
			};
		});

		const writable_props = ["name"];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
		});

		function canvas_1_binding($$value) {
			internal.binding_callbacks[$$value ? "unshift" : "push"](() => {
				canvas = $$value;
				$$invalidate(1, canvas);
			});
		}

		$$self.$$set = $$props => {
			if ("name" in $$props) $$invalidate(0, name = $$props.name);
		};

		$$self.$capture_state = () => ({ name, onMount: svelte.onMount, canvas });

		$$self.$inject_state = $$props => {
			if ("name" in $$props) $$invalidate(0, name = $$props.name);
			if ("canvas" in $$props) $$invalidate(1, canvas = $$props.canvas);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [name, canvas, canvas_1_binding];
	}

	class App extends internal.SvelteComponentDev {
		constructor(options) {
			super(options);
			internal.init(this, options, instance, create_fragment, internal.safe_not_equal, { name: 0 });

			internal.dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "App",
				options,
				id: create_fragment.name
			});

			const { ctx } = this.$$;
			const props = options.props || {};

			if (/*name*/ ctx[0] === undefined && !("name" in props)) {
				console.warn("<App> was created without expected prop 'name'");
			}
		}

		get name() {
			throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set name(value) {
			throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	const app = new App({
	    target: document.body,
	    props: {
	        name: 'World'
	    }
	});

	return app;

}(internal, svelte));
//# sourceMappingURL=bundle.js.map
